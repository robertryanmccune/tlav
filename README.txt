README Think-Like-A-Vertex Framework
Copyright 2024, Robert Ryan McCune <robertryanmccune@gmail.com>

1.	INTRODUCTION

Think-Like-A-Vertex frameworks, also known as vertex-centric
frameworks, or "Pregel"-like frameworks, are systems that
provide a vertex-centric programming model for processing
large-scale graph problems.  Programs are written from
the "perspective of a vertex," which allows for ease of
scalability and fault tolerance.  Programs read input from 
neighbors, perform a simple computation, then send output
messages to neighbors.  The stages of computation occur
for a number of rounds, or "supersteps." 
Global states can be reached using only local computation.  
It is a kind of Map-Reduce for graphs.

Provided in this package is a proof-of-concept prototype that 
demonstrates the programming model. The purpose
is to help further illustrate what is meant by
"think-like-a-vertex."  

In this project, we have developed the base system
and 3 algorithm implementations: breadth-first 
search, connected components, and single-source shortest path.
We also provide a preprocessing program so input graphs
work with the programs

For more information on the original programming model, see:

Malewicz, Grzegorz, et al. "Pregel: a system for 
large-scale graph processing." Proceedings of the 
2010 ACM SIGMOD International Conference on 
Management of data. 2010.

For further information on facets of such systems, see:

McCune, Robert Ryan, Tim Weninger, and Greg Madey. "Thinking 
like a vertex: A survey of vertex-centric frameworks for 
large-scale distributed graph processing." 
ACM Computing Surveys (CSUR) 48.2 (2015): 1-39.

2.  CONTENTS

The contents of this package are as follows:

  README - this directions file
  LICENSE - The BSD license for this software
  Makefile - commands for compilation of all programs
  base/ - file storing base system components
  bfs/ - breadth first search algorithm implementation
  cc/ - connected components algorithm implementation
  data/ - sample data, including unprocessed 
    edgelist, weighted processed and unweighted processed
    edgelists
  lib/ - libraries, including dynamic_array,
    general header, and graph object
  sssp/ - single-source shortest path algorithm implementation
  util/ - edgelist preprocessing components

3.  Graph Formatting

Graphs are expected in edge list format, and also 
expected to be undirected, so every edge is 
listed in both directions, e.g. if the edge
(u,v) exists, then so does edge (v,u) explicitly.  
There are also other graph properties expected, 
such as no self-loops.  

To help comply with these requirements, there is
an edgelist_preprocessing program that takes in an
edgelist and outputs a compliant edgelist

Common sources of graphs include those generated by
the SNAP (snap.stanford.edu) package.

In the data directory, 3 edgelists are provided.
ab_100n_p17.txt is an original edgelist generated by the 
SNAP generator.  ab_100n_p17_unweighted.txt
is the processed graph as an unweighted edgelist.
ab_100n_p17_weighted is the original edgelist
processed with random edgeweights from 1 to 100.
Weighted graphs may be useful when running and
testing single-source shortest path, graphs
typically generated with generators lack edge weight

4.  Compiling and Running the Programs

There are 4 programs provided by this package,
the edgelist preprocessing programs and the
3 algorithm implementations, those of bfs,
cc, and sssp.

All programs were compiled with 
Apple clang version 14.0.3 and 
GNU Make 3.81

4.1 Compile/Erase All Programs

All 4 programs can be compiled by entering:

  make all
  
from the home directory.  All program binaries
can be removed by executing:

  make clean

4.2 Running Edgelist Preprocessing

To compile the edgelist preprocessing program, 
from the util/ folder, execute:

  make all
  
To execute the program, run

  ./edge_preproc  [edgelist_in] [edgelist_out] [weighted]
  
where [edgelist_in] is the edgelist input, [edgelist_out]
is the edgelist outuput, and [weighted] is a 1 or 0 for
whether or not you want the edges to be assigned a
random edgeweight from 1 to 100.  This may be useful
when testing single-source shortest path, since graphs from
generators are often unweighted.  Edgeweights are 
positive to prevent a negative weight cycle

To remove the program, execute from the util/ directory

  make clean 

4.3 Running Breadth-First Search

To compile the program, from the bfs/ folder, execute

  make tlav_bfs
  
To run the program, execute:

  ./tlav_bfs  [edgelist_in] [src] [outfile]
  
where edgelist_in is the processed edgelist input,
src is the source vertex of bfs, and outfile
is the filename to write the output.  The output
is a list of every vertex and the number of hops
from the source node. 

To remove the program, execute:

  make clean

4.4 Running Connected Components

To compile connected components, from the cc/ folder
execute:

  make tlav_cc

To execute the program, run:

  ./tlav_cc [edgelist_in] [outfile]

where edgelist_in is a processed edgelist, and 
[edgelist_out] is where to write each vertex
and its component

Remove the program by executing:

  make clean

4.5 Running Single-Source Shortest Path

Compile single-source shortest path by executing
from the sssp/ folder:

  make tlav_sssp
  
To run the program, execute

  ./tlav_sssp [edgelist_in] [src] [outfile]

where [edgelist_in] is an edgelist, [src] is the 
source-vertex, and outfile is a list of every vertex
and its distance from the source vertex.  
Edgelists may be weighted or unweighted, if 
unweighted then each edge is assigned a weight of 1
and this essentially becomes breadth-first search.
Input graphs must not have cycles of negative weights

5.  Conclusions

This program illustrates the programming model of 
"Think-Like-A-Vertex" frameworks.  The model
is implemented for breadth-first search, connected
components, and single-source shortest path.
A edgelist preprocessing utility is also included
to run the programs with graphs from a generator.

While this a is a proof-of-concept prototype, 
further work could include implementing fault
tolerance, and facilitating distributed computation,
which are the advantages of developing TLAV systems.

For more information on processing graphs based
on linear algebra, see:

Kepner, Jeremy, and John Gilbert, eds. Graph algorithms 
in the language of linear algebra. Society for Industrial 
and Applied Mathematics, 2011.

